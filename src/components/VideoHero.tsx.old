import React, { useEffect, useRef } from 'react';
import styles from './VideoHero.module.css';
import gsap from 'gsap';
import ScrollTrigger from 'gsap/ScrollTrigger';

// Register GSAP plugins
gsap.registerPlugin(ScrollTrigger);

const VideoHero = () => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const sectionRef = useRef<HTMLElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const textContainerRef = useRef<HTMLDivElement>(null);
  const welcomeRef = useRef<HTMLDivElement>(null);
  const toMyRef = useRef<HTMLDivElement>(null);
  const portfolioRef = useRef<HTMLDivElement>(null);
  const scrollTriggerRef = useRef<ScrollTrigger | null>(null);

  useEffect(() => {
    const video = videoRef.current;
    const section = sectionRef.current;
    const container = containerRef.current;
    const textContainer = textContainerRef.current;
    const welcome = welcomeRef.current;
    const toMy = toMyRef.current;
    const portfolio = portfolioRef.current;

    if (!video || !section || !container || !textContainer || !welcome || !toMy || !portfolio) return;

    // Set up initial video state
    video.currentTime = 0;
    video.muted = true; // Ensure muted for autoplay
    video.pause();

    const setupVideoScrolling = () => {
      // Calculate total scroll distance needed for video
      const videoDuration = video.duration;
      const scrollDistance = window.innerHeight * 2.5; // Extended for text animations
      
      console.log('Setting up video scrolling - Duration:', videoDuration, 'Scroll Distance:', scrollDistance);
      
      // Initialize text elements - hidden initially
      gsap.set([welcome, toMy, portfolio], { 
        opacity: 0, 
        scale: 0.8, 
        y: 50,
        rotationX: -15,
        visibility: "hidden"
      });
      
      console.log('Text elements initialized and hidden');

      // Create main timeline
      const mainTL = gsap.timeline({
        scrollTrigger: {
          trigger: section,
          start: "top top",
          end: `+=${scrollDistance}px`,
          pin: true,
          anticipatePin: 1,
          scrub: 0.8,
          markers: false,
          onUpdate: (self: { progress: number, direction: number }) => {
            // Calculate video time based on scroll progress (first 60% of scroll)
            const videoProgress = Math.min(self.progress / 0.6, 1);
            const targetTime = videoProgress * videoDuration;
            
            // Ensure video is playing during scroll
            if (video.paused && videoProgress > 0) {
              video.play().catch(() => {
                // Ignore autoplay errors
              });
            }
            
            // Ensure smooth playback in both directions
            const currentTime = video.currentTime;
            const diff = Math.abs(targetTime - currentTime);
            
            if (diff > 0.1) { // Only update if there's a significant difference
              video.currentTime = targetTime;
            }
          },
          onLeave: (self: { progress: number }) => {
            if (self.progress >= 0.99) {
              gsap.to(section, {
                autoAlpha: 0,
                duration: 0.3,
                onComplete: () => {
                  section.style.visibility = 'hidden';
                }
              });
            }
          },
          onEnterBack: () => {
            section.style.visibility = 'visible';
            gsap.to(section, {
              autoAlpha: 1,
              duration: 0.3
            });
          }
        }
      });

      // Text animations - Sequential, clean transitions
      // Welcome → To My → Portfolio
      mainTL
        // 1. Welcome animation (0-33% of timeline)
        .to(welcome, {
          opacity: 1,
          visibility: "visible",
          scale: 1,
          y: 0,
          rotationX: 0,
          duration: 1,
          ease: "back.out(1.7)"
        }, 0)
        .to(welcome, {}, "+=0.8") // Hold Welcome text
        .to(welcome, {
          opacity: 0,
          visibility: "hidden",
          y: -30,
          scale: 0.9,
          duration: 0.6,
          ease: "power2.in"
        }, 1.8)
        // 2. To My animation (33-66% of timeline)
        .to(toMy, {
          opacity: 1,
          visibility: "visible",
          scale: 1,
          y: 0,
          rotationX: 0,
          duration: 1,
          ease: "back.out(1.7)"
        }, 2.4)
        .to(toMy, {}, "+=0.8") // Hold To My text
        .to(toMy, {
          opacity: 0,
          visibility: "hidden",
          y: -30,
          scale: 0.9,
          duration: 0.6,
          ease: "power2.in"
        }, 4.2)
        // 3. Portfolio animation (66-100% of timeline)
        .to(portfolio, {
          opacity: 1,
          visibility: "visible",
          scale: 1,
          y: 0,
          rotationX: 0,
          duration: 1,
          ease: "back.out(1.7)"
        }, 4.8)
        .to(portfolio, {}, "+=1") // Hold Portfolio text
        .to(portfolio, {
          opacity: 0,
          visibility: "hidden",
          scale: 0.8,
          duration: 0.8,
          ease: "power2.in"
        }, 6.8);

      scrollTriggerRef.current = mainTL.scrollTrigger;
      return mainTL;
    };

    // Wait for video metadata to load before setting up scroll
    const handleVideoLoad = () => {
      console.log('Video loaded, duration:', video.duration);
      const timeline = setupVideoScrolling();
      scrollTriggerRef.current = timeline.scrollTrigger;
    };

    const handleVideoError = (e: Event) => {
      console.error('Video loading error:', e);
    };

    const handleVideoCanPlay = () => {
      console.log('Video can play');
      // Try to play the video initially (will be paused immediately by setupVideoScrolling)
      video.play().then(() => {
        video.pause();
        video.currentTime = 0;
      }).catch((error) => {
        console.log('Autoplay prevented:', error);
      });
    };

    video.addEventListener('loadedmetadata', handleVideoLoad);
    video.addEventListener('error', handleVideoError);
    video.addEventListener('canplay', handleVideoCanPlay);

    // Force load the video
    video.load();

    // Cleanup
    return () => {
      video.removeEventListener('loadedmetadata', handleVideoLoad);
      video.removeEventListener('error', handleVideoError);
      video.removeEventListener('canplay', handleVideoCanPlay);
      scrollTriggerRef.current?.kill();
      ScrollTrigger.getAll().forEach(t => t.kill());
    };
  }, []);

  return (
    <section 
      ref={sectionRef}
      id="video-hero"
      className={styles['video-section']}
    >
      <div 
        ref={containerRef}
        className={styles['video-container']}
      >
        <video
          ref={videoRef}
          muted
          playsInline
          preload="auto"
          loop={false}
          controls={false}
          className={styles.video}
        >
          <source src="/landing_vid.mp4" type="video/mp4" />
          Your browser does not support the video tag.
        </video>
      </div>

      {/* Animated Text Container */}
      <div 
        ref={textContainerRef}
        className={styles['text-overlay']}
      >
        {/* Welcome Text */}
        <div 
          ref={welcomeRef}
          className={styles['text-element']}
        >
          <h1 className={styles['welcome-text']}>Welcome</h1>
        </div>

        {/* To My Text */}
        <div 
          ref={toMyRef}
          className={styles['text-element']}
        >
          <h1 className={styles['to-my-text']}>To My</h1>
        </div>

        {/* Portfolio Text */
        <div 
          ref={portfolioRef}
          className={styles['text-element']}
        >
          <h1 className={styles['portfolio-text']}>Portfolio</h1>
        </div>
      </div>
      
      <div className={styles['scroll-prompt']}>
        <div className={styles['scroll-box']}>
          <div className={styles['scroll-text']}>
            Scroll down to begin
          </div>
          <div className={styles['scroll-icon']}>
            <svg 
              className="w-5 h-5" 
              fill="none" 
              stroke="currentColor" 
              viewBox="0 0 24 24"
            >
              <path 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                strokeWidth={2} 
                d="M19 14l-7 7m0 0l-7-7m7 7V3"
              />
            </svg>
          </div>
        </div>
      </div>
    </section>
  );
};

export default VideoHero;